#!/usr/bin/env python3

import sys
import os
import re
import stat
from pathlib import Path
from argparse import ArgumentParser
import json
from subprocess import check_call


template_var_arg_re = re.compile(r'(\w+)=(.*)')
template_re = re.compile(r'(?<!\\)%(\w+)%')
templates_path = (Path(os.environ['CONFIG']) / 'new').resolve()


def expect(name, expected, result):
    if result != expected:
        print('For {} expected:\n{}\nBut got:\n{}'.format(
            name, repr(expected), repr(result)), file=sys.stderr)
        sys.exit(1)


def resolve(template_vars, text, recursive=True, restrict=lambda s: True):
    if isinstance(text, list):
        return [resolve(template_vars, t, recursive, restrict) for t in text]
    while True:
        last = text
        var_names = set(filter(restrict, template_re.findall(text)))
        for var_name in var_names:
            text = re.sub(r'(?<!\\)%{}%'.format(var_name), template_vars[var_name], text)
        if not var_names:
            break
        if text == last:
            raise ValueError('Would cause infinite loop')
        if not recursive:
            break
    return text


def test_resolve():
    template_vars = {
        'simple': 'easy',
        'escaped': '\%escaped%',
        'redirect1': '%simple%%escaped%',
        'redirect2': '%redirect1%',
    }
    result = resolve(template_vars, '''
Hello %simple%
%escaped% \%escaped%
%redirect1%
%redirect2%
''')
    expect('recursive resolve test', '''
Hello easy
\%escaped% \%escaped%
easy\%escaped%
easy\%escaped%
''', result)

    # Detect Infinite Loop
    caught = False
    try:
        resolve({'loop': '%loop%'}, '%loop%', recursive=False)
    except ValueError:
        caught = True
    expect('detect infinite loop', True, caught)


def read_new_json(dir_path, template_vars, recursive=False):
    dir_paths = [dir_path]
    if recursive:
        dir_paths.extend(dir_path.parents)
    for dir_path in reversed(dir_paths):
        path = dir_path / 'new.json'
        if path.exists():
            with path.open() as f:
                for name, value in json.load(f).items():
                    template_vars[name] = resolve({'new_json_dir': str(dir_path)}, value,
                        restrict=lambda s: s == 'new_json_dir')


def new(kind, dest_path, override_vars={}):
    dest_path = dest_path.resolve()
    template_path = templates_path / kind
    template_vars = {}
    read_new_json(templates_path, template_vars)
    read_new_json(template_path, template_vars)
    read_new_json(dest_path, template_vars, recursive=True)
    template_vars['dest'] = str(dest_path)
    print(template_vars)
    template_vars.update(override_vars)
    for path in template_path.rglob('*'):
        if path.name == 'new.json':
            continue
        rel = path.relative_to(template_path)
        print(rel)
        new_path = dest_path / rel
        new_path.parent.mkdir(parents=True, exist_ok=True)
        new_path.write_text(resolve(template_vars, path.read_text()))
        new_path.chmod(path.stat().st_mode)
    if 'new_post_command' in template_vars:
        check_call(resolve(template_vars, template_vars['new_post_command']), cwd=dest_path)


def run_tests():
    test_resolve()
    print('Tests Finished')


if __name__ == '__main__':
    argparser = ArgumentParser()
    argparser.add_argument('kind')
    argparser.add_argument('dest', type=Path, nargs='?', default=Path('.'))
    argparser.add_argument('-D', dest='template_vars', default=[], action='append')
    args = argparser.parse_args()

    if args.kind == 'test':
        run_tests()
        sys.exit()

    template_vars = {}
    for arg in args.template_vars:
        m = template_var_arg_re.fullmatch(arg)
        if not m:
            sys.exit(repr(arg) +
                " is not a valid argument to -D. Must be in the form of -D name=value")
        template_vars[m.group(1)] = m.group(2)

    new(args.kind, args.dest, override_vars=template_vars)
